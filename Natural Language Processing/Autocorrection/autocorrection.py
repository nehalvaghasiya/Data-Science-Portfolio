# -*- coding: utf-8 -*-
"""Autocorrection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ew510ZoOYYsY7wjTwPytGAX9a9hkbICa

We are using autocorrect every day on your cell phone and computer. In this project, I will discuss what really goes on behind the scenes.
> > ![download.jpg](data:image/jpeg;base64,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)

# Edit Distance algorithm
- Implemention of model in which correct words that are 1 and 2 edit distances away
- An edit could consist of one of the following options:

1. Delete (remove a letter): ‘hat’ => ‘at, ha, ht’
2. Switch (swap 2 adjacent letters): ‘eta’ => ‘eat, tea,...’
3. Replace (change 1 letter to another): ‘jat’ => ‘hat, rat, cat, mat, ...’
4. Insert (add a letter): ‘te’ => ‘the, ten, ate, ...’

# Data Preprocessing
"""

import re
from collections import Counter
import numpy as np
import pandas as pd

def process_data(file_name):
  
    words = [] # return this variable correctly

    
    with open(file_name) as f:
        text = f.read()
    text_lowercase = text.lower()
    words = re.findall(r'\w+', text_lowercase)
 
    return words

word_l = process_data('/content/drive/MyDrive/Colab Notebooks/natural language processing/Autocorrection/shakespeare.txt')
vocab = set(word_l)  # this will be your new vocabulary
print(f"The first ten words in the text are: \n{word_l[0:10]}")
print(f"There are {len(vocab)} unique words in the vocabulary.")

"""#Counting each word is the number of times that word appears in the corpus"""

def get_count(word_l):

    word_count_dict = {}  # fill this with word counts
    
    for word in word_l:
        word_count_dict[word] = word_count_dict.get(word,0)+1
  
    return word_count_dict

word_count_dict = get_count(word_l)
print(f"There are {len(word_count_dict)} key values pairs")
print(f"The count for the word 'thee' is {word_count_dict.get('thee',0)}")

"""# Probability that a word occurs in a sample"""

def get_probs(word_count_dict):
    
    probs = {}  # return this variable correctly

    count =0
    for i in word_count_dict.values():
        count= count+i
    for word in word_count_dict.keys():
        p = word_count_dict[word]/count
        probs[word] = p

    return probs

probs = get_probs(word_count_dict)
print(f"Length of probs is {len(probs)}")
print(f"P('thee') is {probs['thee']:.4f}")

"""# String Manipulations

- delete_letter: given a word, it returns all the possible strings that have one character removed.
- switch_letter: given a word, it returns all the possible strings that have two adjacent letters switched.
- replace_letter: given a word, it returns all the possible strings that have one character replaced by another different letter.
- insert_letter: given a word, it returns all the possible strings that have an additional character inserted.
"""

def delete_letter(word, verbose=False):
   
    
    delete_l = []
    split_l = []

    for c in range(len(word)):
        split_l.append((word[:c],word[c:]))
    for a,b in split_l:
        delete_l.append(a+b[1:])   
 

    if verbose: print(f"input word {word}, \nsplit_l = {split_l}, \ndelete_l = {delete_l}")

    return delete_l

delete_word_l = delete_letter(word="cans",
                        verbose=True)

print(f"Number of outputs of delete_letter('at') is {len(delete_letter('at'))}")

def switch_letter(word, verbose=False):
    
    switch_l = []
    split_l = []
    
    
    def swap(c, i, j):
        c = list(c)
        c[i], c[j] = c[j], c[i]
        return ''.join(c)
    
    switch_l = []
    split_l = []
    len_word=len(word)
    
    for c in range(len_word):
        split_l.append((word[:c],word[c:]))
    switch_l = [a + b[1] + b[0] + b[2:] for a,b in split_l if len(b) >= 2]  
    
    
    if verbose: print(f"Input word = {word} \nsplit_l = {split_l} \nswitch_l = {switch_l}") 

    return switch_l

switch_word_l = switch_letter(word="eta",
                         verbose=True)

print(f"Number of outputs of switch_letter('at') is {len(switch_letter('at'))}")

def replace_letter(word, verbose=False):
   
    
    letters = 'abcdefghijklmnopqrstuvwxyz'
    replace_l = []
    split_l = []
    
    
    for c in range(len(word)):
        split_l.append((word[0:c],word[c:]))
    replace_l = [a + l + (b[1:] if len(b)> 1 else '') for a,b in split_l if b for l in letters]
    replace_set=set(replace_l)    
    replace_set.remove(word)
    
    
    # turn the set back into a list and sort it, for easier viewing
    replace_l = sorted(list(replace_set))
    
    if verbose: print(f"Input word = {word} \nsplit_l = {split_l} \nreplace_l {replace_l}")   
    
    return replace_l

replace_l = replace_letter(word='can',
                              verbose=True)

print(f"Number of outputs of switch_letter('at') is {len(switch_letter('at'))}")

def insert_letter(word, verbose=False):
 
    letters = 'abcdefghijklmnopqrstuvwxyz'
    insert_l = []
    split_l = []
    
  
    for c in range(len(word)+1):
        split_l.append((word[0:c],word[c:]))
    insert_l = [ a + l + b for a,b in split_l for l in letters]
   

    if verbose: print(f"Input word {word} \nsplit_l = {split_l} \ninsert_l = {insert_l}")
    
    return insert_l

insert_l = insert_letter('at', True)
print(f"Number of strings output by insert_letter('at') is {len(insert_l)}")

print(f"Number of outputs of insert_letter('at') is {len(insert_letter('at'))}")

"""#Combining the edits

- edit_one_letter function: get all the possible edits that are one edit away from a word

- edit_two_letters function: returns a set of words that are two edits away

- get_corrections: returns a list of zero to n possible suggestion tuples of the form (word, probability_of_word)
"""

def edit_one_letter(word, allow_switches = True):

    edit_one_set = set()

    edit_one_set.update(delete_letter(word))
    if allow_switches:
        edit_one_set.update(switch_letter(word))
    edit_one_set.update(replace_letter(word))
    edit_one_set.update(insert_letter(word))
  

    return edit_one_set

tmp_word = "at"
tmp_edit_one_set = edit_one_letter(tmp_word)
# turn this into a list to sort it, in order to view it
tmp_edit_one_l = sorted(list(tmp_edit_one_set))

print(f"input word {tmp_word} \nedit_one_l \n{tmp_edit_one_l}\n")
print(f"The type of the returned object should be a set {type(tmp_edit_one_set)}")
print(f"Number of outputs from edit_one_letter('at') is {len(edit_one_letter('at'))}")

def edit_two_letters(word, allow_switches = True):
  
    edit_two_set = set()
   
    edit_one = edit_one_letter(word,allow_switches=allow_switches)
    for w in edit_one:
        if w:
            edit_two = edit_one_letter(w,allow_switches=allow_switches)
            edit_two_set.update(edit_two)
    
    return edit_two_set

tmp_edit_two_set = edit_two_letters("a")
tmp_edit_two_l = sorted(list(tmp_edit_two_set))
print(f"Number of strings with edit distance of two: {len(tmp_edit_two_l)}")
print(f"First 10 strings {tmp_edit_two_l[:10]}")
print(f"Last 10 strings {tmp_edit_two_l[-10:]}")
print(f"The data type of the returned object should be a set {type(tmp_edit_two_set)}")
print(f"Number of strings that are 2 edit distances from 'at' is {len(edit_two_letters('at'))}")

def get_corrections(word, probs, vocab, n=2, verbose = False):
    
    suggestions = []
    n_best = []

    suggestions = list((word in vocab and word) or edit_one_letter(word).intersection(vocab) or edit_two_letters(word).intersection(vocab))
    n_best = [[s,probs[s]] for s in list(reversed(suggestions))]

    if verbose: print("Entered word = ", word, "and Suggestions = ", suggestions)

    return n_best

my_word = 'dys' 
tmp_corrections = get_corrections(my_word, probs, vocab, 2, verbose=True) # keep verbose=True
for i, word_prob in enumerate(tmp_corrections):
    print(f"word {i}: {word_prob[0]}, probability {word_prob[1]:.6f}")

print(f"data type of corrections {type(tmp_corrections)}")

"""# Minimum Edit distance

- Evaluate the similarity between two strings- For example: 'waht' and 'what'
- Efficiently find the shortest path to go from the word, 'waht' to the word 'what'
"""

def min_edit_distance(source, target, ins_cost = 1, del_cost = 1, rep_cost = 2):

    # use deletion and insert cost as  1
    m = len(source) 
    n = len(target) 
    #initialize cost matrix with zeros and dimensions (m+1,n+1) 
    D = np.zeros((m+1, n+1), dtype=int) 
    
    # Fill in column 0, from row 1 to row m, both inclusive
    for row in range(1,m+1): # Replace None with the proper range
        D[row,0] = D[row-1,0] + del_cost
        
    # Fill in row 0, for all columns from 1 to n, both inclusive
    for col in range(1,n+1): # Replace None with the proper range
        D[0,col] = D[0,col-1] + ins_cost
        
    # Loop through row 1 to row m, both inclusive
    for row in range(1,m+1): 
        
        # Loop through column 1 to column n, both inclusive
        for col in range(1,n+1):
            
            # Intialize r_cost to the 'replace' cost that is passed into this function
            r_cost = rep_cost
            
            # Check to see if source character at the previous row
            # matches the target character at the previous column, 
            if source[row-1] == target[col-1]:
                # Update the replacement cost to 0 if source and target are the same
                r_cost = 0
                
            # Update the cost at row, col based on previous entries in the cost matrix
            D[row,col] = min([D[row-1,col]+del_cost, D[row,col-1]+ins_cost, D[row-1,col-1]+r_cost])
          
    # Set the minimum edit distance with the cost found at row m, column n
    med = D[m,n]
    
    return D, med

source =  'play'
target = 'stay'
matrix, min_edits = min_edit_distance(source, target)
print("minimum edits: ",min_edits, "\n")
idx = list('#' + source)
cols = list('#' + target)
df = pd.DataFrame(matrix, index=idx, columns= cols)
print(df)

source =  'eer'
target = 'near'
matrix, min_edits = min_edit_distance(source, target)
print("minimum edits: ",min_edits, "\n")
idx = list(source)
idx.insert(0, '#')
cols = list(target)
cols.insert(0, '#')
df = pd.DataFrame(matrix, index=idx, columns= cols)
print(df)